//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;

import java.text.ParseException;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */

public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   static public class Pair {
      public String p1;
      public String p2;
   }

   public HashMap<String, HashMap<String, String>> class_vars = new HashMap<>();
   public HashMap<String, HashMap<String,  GJNoArguDepthFirst.func_type>> class_functions = new HashMap<>();
   ArrayList<HashMap<String, String>> vars_stack = new ArrayList<>();
   public HashMap<String, String> parent_class = new HashMap<>();
   String curr_class = null;
   String curr_method = null;
   String no_parent = "None_ved_here_630";

   public void symbol_not_found(String e) {
      System.out.println("Symbol not found");
      // System.out.println(e);
      System.exit(1);
   }

   public void type_error(String e) {
      System.out.println("Type error");
      // System.out.println(e);
      System.exit(1);
   }

   // checks if t1 is child of t2
   public boolean is_subtype(String t1, String t2) {
      if (is_lambda_type(t1) && is_lambda_type(t2)) {
         Boolean argu_match = get_argument_type_of_lambda(t1).equals(get_argument_type_of_lambda(t2));
         Boolean return_match = is_subtype(get_return_type_of_lambda(t1), get_return_type_of_lambda(t2));
         return argu_match && return_match;
      }

      if (t1.equals(t2)) return true;
      else if (!parent_class.containsKey(t1) || parent_class.get(t1).equals(no_parent)) return false;
      else return is_subtype(parent_class.get(t1), t2);
   }

   public boolean verify_child(String child, String parent) {
      if (parent.equals(no_parent)) return false;
      for (Map.Entry<String, GJNoArguDepthFirst.func_type> entry : class_functions.get(child).entrySet()) {
         String fName = entry.getKey();
         String rType = entry.getValue().rType();
         ArrayList<String> params = entry.getValue().params();

         if (class_functions.get(parent).containsKey(fName)) {
            ArrayList<String> parent_params = class_functions.get(parent).get(fName).params();
            String pRType = class_functions.get(parent).get(fName).rType();

            if (!params.equals(parent_params) || !is_subtype(rType, pRType)) return true;
         }
      }
      return verify_child(child, parent_class.get(parent));
   }

   public HashMap<String, String> get_vars(NodeListOptional n) {
      HashMap<String, String> vars = new HashMap<>();
      if (!n.present()) {
         return vars;
      }
      A argu = null;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         Pair np = (Pair) e.nextElement().accept(this,argu);
         vars.put(np.p1, np.p2);
      }
      return vars;
   }

   // public ArrayList<String> get_expr_list(NodeListOptional n) {
   //    ArrayList<String> vars = new ArrayList<>();
   //    if (!n.present()) {
   //       return vars;
   //    }
   //    A argu = null;
   //    for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
   //       String ns = (String) e.nextElement().accept(this,argu);
   //       vars.add(ns);
   //    }
   //    return vars;
   // }

   public boolean is_lambda_type(String typ) {
      // System.out.println(typ);
      return typ.charAt(0) == '<';
   }

   public String get_argument_type_of_lambda(String typ) {
      String[] parts = typ.substring(1, typ.length() -1).split(",", 2);
      return parts[0];
   }

   public String get_return_type_of_lambda(String typ) {
      String[] parts = typ.substring(1, typ.length() -1).split(",", 2);
      return parts[1];
   }

   public String get_var_type(String id) {
      for (int i = vars_stack.size() - 1; i >= 0; i--) {
         var variables = vars_stack.get(i);
         if (variables.containsKey(id)) {
            return variables.get(id);
         }
      }
      return null;
   }

   public Boolean check_func_params(ArrayList<String> a1, ArrayList<String> a2) {
      if (a1.size() != a2.size()) return true;

      for (int i = 0; i < a1.size(); i++) {
         if (!is_subtype(a2.get(i), a1.get(i))) 
            return true;
      }
      return false;
   }

   public void add_parent_vars(ArrayList<HashMap<String,String>> stack_of_var, String node) {
      node = parent_class.get(node);
      if (node.equals(no_parent)) return;
      add_parent_vars(stack_of_var, node);
      stack_of_var.add(class_vars.get(node));
   }

   public GJNoArguDepthFirst.func_type find_function(String node, String func_name) {
      while(!node.equals(no_parent)) {
         if (class_functions.get(node).containsKey(func_name)) {
            return class_functions.get(node).get(func_name);
         }
         node = parent_class.get(node);
      }
      return null;
   }

   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> ( ImportFunction() )?
    * f1 -> MainClass()
    * f2 -> ( TypeDeclaration() )*
    * f3 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      class_vars.put("Integer", new HashMap<>());
      class_vars.put("Boolean", new HashMap<>());
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "import"
    * f1 -> "java.util.function.Function"
    * f2 -> ";"
    */
   public R visit(ImportFunction n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public R visit(MainClass n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      curr_class = (String) n.f1.accept(this, argu);
      curr_method = "main";
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      n.f11.accept(this, argu);
      n.f12.accept(this, argu);
      n.f13.accept(this, argu);
      n.f14.accept(this, argu);
      n.f15.accept(this, argu);
      n.f16.accept(this, argu);
      curr_method = null;
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      curr_class = (String) n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      vars_stack.add(get_vars(n.f3));
      assert(vars_stack.getLast().equals(class_vars.get(curr_class))) : "class vars not matching";
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      vars_stack.removeLast();
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      curr_class = (String) n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String parent = (String) n.f3.accept(this, argu);
      if (!class_vars.containsKey(parent)) {
         symbol_not_found(parent + " not a class");
      }
      if (parent.equals("Integer") || parent.equals("Boolean")) {
         type_error("bad parent: " + parent);
      }
      if (verify_child(curr_class, parent)) {
         type_error(curr_class + " bad child");
      }
      add_parent_vars(vars_stack, curr_class);
      // vars_stack.add(class_vars.get(parent));
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      vars_stack.add(get_vars(n.f5));
      assert(vars_stack.getLast().equals(class_vars.get(curr_class))) : "class vars not matching";
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      vars_stack.removeLast();
      vars_stack.removeLast();
      vars_stack.clear();
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n, A argu) {
      String typ = (String) n.f0.accept(this, argu);
      String id = (String) n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      Pair np = new Pair();
      np.p1 = id;
      np.p2 = typ;
      return (R) np;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String rType = (String) n.f1.accept(this, argu);
      String name = (String) n.f2.accept(this, argu);
      curr_method = name;
      n.f3.accept(this, argu);
      R temp = n.f4.accept(this, argu);
      HashMap<String, String> vars = new HashMap<>();
      if (temp != null) vars.putAll((HashMap<String, String>) temp);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      vars.putAll(get_vars(n.f7));
      vars_stack.add(vars);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      A new_argu = null;
      if (is_lambda_type(rType)) {
         new_argu = (A) get_argument_type_of_lambda(rType);
      }
      String returnType = (String) n.f10.accept(this, new_argu);
      if (!is_subtype(returnType, rType)) 
         type_error("method return type, " + curr_class + ": " + name + " ex type: " + rType + " but type: " + returnType);
      n.f11.accept(this, argu);
      n.f12.accept(this, argu);
      vars_stack.removeLast();
      curr_method = null;
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n, A argu) {
      Pair p = (Pair) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      HashMap<String, String> vars = get_vars(n.f1);
      vars.put(p.p1, p.p2);
      return (R) vars;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n, A argu) {
      String typ = (String) n.f0.accept(this, argu);
      String name = (String) n.f1.accept(this, argu);
      Pair p = new Pair();
      p.p1 = name;
      p.p2 = typ;
      return (R) p;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    *       | LambdaType()
    */
   public R visit(Type n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      if (n.f0.which == 3) {
         String id = (String) _ret;
         if (!class_vars.containsKey(id)) 
            symbol_not_found("In type, identifier is not a class. id: " + (String) _ret);
         // if (id.equals("Integer") || id.equals("Boolean"))
         //    type_error("Unmanted type: " + id);
      }
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return (R) ("int[]");
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n, A argu) {
      n.f0.accept(this, argu);
      return (R) "Boolean";
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n, A argu) {
      n.f0.accept(this, argu);
      return (R) "Integer";
   }

   /**
    * f0 -> "Function"
    * f1 -> "<"
    * f2 -> Identifier()
    * f3 -> ","
    * f4 -> Identifier()
    * f5 -> ">"
    */
   public R visit(LambdaType n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String res1 = (String) n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      String res2 = (String) n.f4.accept(this, argu);
      n.f5.accept(this, argu);

      if (!class_vars.containsKey(res1) || !class_vars.containsKey(res2)) 
         symbol_not_found("In LambdaType, res1: " + res1 + " res2: " + res2);
      return (R) ("<" + res1 + "," + res2 + ">");
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n, A argu) {
      R _ret=null;
      String id = (String) n.f0.accept(this, argu);
      String var_type = get_var_type(id);
      if (var_type == null)   
         symbol_not_found("id: " + id + " not found in assignment statement. " + curr_class + " " + curr_method);

      A new_argu = null;
      if (is_lambda_type(var_type))
         new_argu = (A) get_argument_type_of_lambda(var_type);
      
      n.f1.accept(this, argu);
      String typ = (String) n.f2.accept(this, new_argu);
      n.f3.accept(this, argu);

      if (!is_subtype(typ, var_type))
         type_error("In assignment statement id type: " + var_type + " != " + "exp type: " + typ);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n, A argu) {
      R _ret=null;
      String id = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ1 = (String) n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      String typ2 = (String) n.f5.accept(this, argu);

      String id_type = get_var_type(id);
      if (id_type == null)
         symbol_not_found("In arrayassignment statement id symbol not found, id: " + id);

      if (!id_type.equals("int[]") || !typ1.equals("Integer") || !typ2.equals("Integer")) 
         type_error("unexpected types in array assignment statement, id: " + id_type + " exp1: " + typ1 + " exp2: " + typ2);

      n.f6.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public R visit(IfStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(IfthenStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ = (String) n.f2.accept(this, argu);
      if (!typ.equals("Boolean"))
         type_error("In if-then statement, type = " + typ);
      
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfthenElseStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ = (String) n.f2.accept(this, argu);
      if (!typ.equals("Boolean")) 
         type_error("In if-then-else statement, type = " + typ);

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ = (String) n.f2.accept(this, argu);
      if (!typ.equals("Boolean")) 
         type_error("In while statement, type = " + typ);

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ = (String) n.f2.accept(this, argu);
      if (!typ.equals("Integer")) 
         type_error("In print statement, type: " + typ);

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | AddExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | LambdaExpression()
    *       | PrimaryExpression()
    */
   public R visit(Expression n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Identifier()
    * f2 -> ")"
    * f3 -> "->"
    * f4 -> Expression()
    */
   public R visit(LambdaExpression n, A argu) {
      R _ret=null;
      if (argu == null) 
         type_error("no argu in lambda expression");

      n.f0.accept(this, argu);
      String id = (String) n.f1.accept(this, argu);
      HashMap<String, String> lam_var = new HashMap<>();
      lam_var.put(id, (String)argu);
      vars_stack.add(lam_var);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      A save_argu = argu;
      String typ = (String) n.f4.accept(this, null);
      
      vars_stack.removeLast();
      _ret = (R) ("<" + (String)save_argu + "," + typ + ">");
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public R visit(AndExpression n, A argu) {
      R _ret=null;
      argu = null;
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ2 = (String) n.f2.accept(this, argu);
      
      if (!typ1.equals("Boolean") || !typ2.equals("Boolean"))
         type_error("In and expression, typ1 = " + typ1 + " typ2 = " + typ2);
      _ret = (R) "Boolean"; 
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public R visit(OrExpression n, A argu) {
      R _ret=null;
      argu = null;
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ2 = (String) n.f2.accept(this, argu);
      
      if (!typ1.equals("Boolean") || !typ2.equals("Boolean"))
         type_error("In or expression, typ1 = " + typ1 + " typ2 = " + typ2);
      _ret = (R) "Boolean"; 
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public R visit(CompareExpression n, A argu) {
      R _ret=null;
      argu = null;
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ2 = (String) n.f2.accept(this, argu);
      
      if (!typ1.equals("Integer") || !typ2.equals("Integer"))
         type_error("In compare expression, typ1 = " + typ1 + " typ2 = " + typ2);
      _ret = (R) "Boolean"; 
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public R visit(neqExpression n, A argu) {
      R _ret=null;
      argu = null;
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ2 = (String) n.f2.accept(this, argu);

      if (!is_subtype(typ1, typ2) && !is_subtype(typ2, typ1))
         type_error("In neq expression, typ1 = " + typ1 + " typ2 = " + typ2);
      _ret = (R) "Boolean";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(AddExpression n, A argu) {
      R _ret=null;
      argu = null;
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ2 = (String) n.f2.accept(this, argu);

      if (!typ1.equals("Integer") || !typ2.equals("Integer"))
         type_error("In add expression, typ1: " + typ1 + " typ2: " + typ2);
      _ret = (R) "Integer";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n, A argu) {
      R _ret=null;
      argu = null;
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ2 = (String) n.f2.accept(this, argu);

      if (!typ1.equals("Integer") || !typ2.equals("Integer"))
         type_error("In minus expression, typ1: " + typ1 + " typ2: " + typ2);
      _ret = (R) "Integer";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n, A argu) {
      R _ret=null;
      argu = null;
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ2 = (String) n.f2.accept(this, argu);

      if (!typ1.equals("Integer") || !typ2.equals("Integer"))
         type_error("In times expression, typ1: " + typ1 + " typ2: " + typ2);
      _ret = (R) "Integer";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public R visit(DivExpression n, A argu) {
      R _ret=null;
      argu = null;
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ2 = (String) n.f2.accept(this, argu);

      if (!typ1.equals("Integer") || !typ2.equals("Integer"))
         type_error("In div expression, typ1: " + typ1 + " typ2: " + typ2);
      _ret = (R) "Integer";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n, A argu) {
      R _ret=null;
      argu = null;
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String typ2 = (String) n.f2.accept(this, argu);
      n.f3.accept(this, argu);

      if (!typ1.equals("int[]") || !typ2.equals("Integer"))
         type_error("In arraylookup, typ1: " + typ1 + " typ2: " + typ2);
      _ret = (R) "Integer";
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n, A argu) {
      R _ret=null;
      argu = null;
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      if (!typ1.equals("int[]"))
         type_error("In arraylength, typ1: " + typ1);
      _ret = (R) "Integer";
      return _ret;
   }

   ArrayList<String> get_params(NodeOptional n, ArrayList<String> func_params) {
      ArrayList<String> params = new ArrayList<>();
      if (n.present()) {
         ExpressionList el = (ExpressionList)n.node;
         int count = 1 + el.f1.size();
         if (count != func_params.size()) 
            type_error("func params sizes dont match");

         A arg = null;
         if (is_lambda_type(func_params.get(0))) {
            arg = (A) get_argument_type_of_lambda(func_params.get(0));
         }

         String typ1 = (String) el.f0.accept(this, arg);
         params.add(typ1);
         int i = 1;
         for (Enumeration<Node> e = el.f1.elements(); e.hasMoreElements();) {
            A arg_ = null;
            if (is_lambda_type(func_params.get(i))) {
               arg_ = (A) get_argument_type_of_lambda(func_params.get(i));
            }

            params.add((String)e.nextElement().accept(this, arg_));
            i++;
         }
      }
      return params;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n, A argu) {
      R _ret=null;
      argu = null;
      String id1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String id2 = (String) n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      // ArrayList<String> params = new ArrayList<>();
      // R ret = n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      // if (ret != null) 
      //    params = (ArrayList<String>) ret;

      if (!is_lambda_type(id1)) {
         String class_name = id1;
         if (id1.equals("Integer") || id1.equals("Boolean"))
            type_error("int/bool found in lambda apply");
         if (id1.equals("int[]"))
            symbol_not_found("array type found in lambda");
         
         GJNoArguDepthFirst.func_type func_obj = find_function(class_name, id2);
         if (func_obj == null)
            symbol_not_found("In message send, function not found. class: " + class_name + ", function: "+ id2);

         String rType = func_obj.rType();
         ArrayList<String> func_params = func_obj.params();
         ArrayList<String> params = get_params(n.f4, func_params);

         if (check_func_params(func_params, params))
            type_error("In message send, func params dont match. class: " + class_name + " func: " + id2 + ", func_params = " + func_params.toString() + " params = " + params.toString());
         
         _ret = (R) rType;
      } else {
         if (!id2.equals("apply"))
            symbol_not_found("In message send, expected apply in case of lambda. id1 = " + id1 + " id2 = " + id2);
         
         if (!n.f4.present() || ((ExpressionList)n.f4.node).f1.size() != 0)
               type_error("In lambda apply, sizes dont match");
         
         String param = (String)((ExpressionList)n.f4.node).f0.accept(this, null);
         if (!is_subtype(param, get_argument_type_of_lambda(id1)))
            type_error("In message send in case of lambda, expected type: " + id1 + " param: " + param);
         
         _ret = (R) get_return_type_of_lambda(id1);
      }
      
      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n, A argu) {
      String typ1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      // ArrayList<String> params_rest = get_expr_list(n.f1);
      // params_rest.add(0, typ1);
      // return (R) params_rest;
      return null;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public R visit(PrimaryExpression n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      if (n.f0.which == 3) {
         String id = (String) _ret;
         // System.out.print(id);
         String typ = get_var_type(id);
         if (typ == null) 
            symbol_not_found("variable doesn't exist, id: " + id);
         _ret = (R) typ;
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = (R) "Integer";
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = (R) "Boolean";
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = (R) "Boolean";
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n, A argu) {
      n.f0.accept(this, argu);
      String val = n.f0.toString();
      return (R) val;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = (R) curr_class;
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n, A argu) {
      R _ret=null;
      argu = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String typ = (String) n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      if (!typ.equals("Integer"))
         type_error("In array alloc, typ: " + typ);
      _ret = (R) "int[]";
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String id = (String) n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);

      if (id.equals("Integer") || id.equals("Boolean"))
         type_error("In alloc, id is primitive type. id: " + id);

      if(!class_vars.containsKey(id))
         symbol_not_found("In alloc, id: " + id);
         
      _ret = (R) id;
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public R visit(NotExpression n, A argu) {
      R _ret=null;
      argu = null;
      n.f0.accept(this, argu);
      String typ = (String) n.f1.accept(this, argu);

      if (!typ.equals("Boolean"))
         type_error("In not expr, typ: " + typ);
      _ret = (R) "Boolean";
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

}
